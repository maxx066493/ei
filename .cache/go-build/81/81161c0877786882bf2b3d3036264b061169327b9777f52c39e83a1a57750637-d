// Code generated by cmd/cgo; DO NOT EDIT.

//line /root/go/pkg/mod/github.com/ethereum/go-ethereum@v1.13.4/crypto/secp256k1/secp256.go:1:1
// Copyright 2015 Jeffrey Wilcke, Felix Lange, Gustav Simonsson. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found in
// the LICENSE file.

//go:build !gofuzz && cgo
// +build !gofuzz,cgo

// Package secp256k1 wraps the bitcoin secp256k1 C library.
package secp256k1; import _cgo_unsafe "unsafe"

/*
#cgo CFLAGS: -I./libsecp256k1
#cgo CFLAGS: -I./libsecp256k1/src/

#ifdef __SIZEOF_INT128__
#  define HAVE___INT128
#  define USE_FIELD_5X52
#  define USE_SCALAR_4X64
#else
#  define USE_FIELD_10X26
#  define USE_SCALAR_8X32
#endif

#ifndef NDEBUG
#  define NDEBUG
#endif

#define USE_ENDOMORPHISM
#define USE_NUM_NONE
#define USE_FIELD_INV_BUILTIN
#define USE_SCALAR_INV_BUILTIN
#include "./libsecp256k1/src/secp256k1.c"
#include "./libsecp256k1/src/modules/recovery/main_impl.h"
#include "ext.h"

typedef void (*callbackFunc) (const char* msg, void* data);
extern void secp256k1GoPanicIllegal(const char* msg, void* data);
extern void secp256k1GoPanicError(const char* msg, void* data);
*/
import _ "unsafe"

import (
	"errors"
	"math/big"
	"unsafe"
)

var context * /*line :48:14*/_Ctype_secp256k1_context /*line :48:33*/

func init() {
	// around 20 ms on a modern CPU.
	context = ( /*line :52:12*/_Cfunc_secp256k1_context_create_sign_verify /*line :52:49*/)()
	func() { _cgo0 := /*line :53:43*/context; var _cgo1 *[0]byte = _Ctype_callbackFunc /*line :53:66*/(_Cgo_ptr(_Cfpvar_fp_secp256k1GoPanicIllegal /*line :53:92*/)); var _cgo2 _cgo_unsafe.Pointer = /*line :53:95*/nil; _cgoCheckPointer(_cgo0, nil); /*line :53:99*/_Cfunc_secp256k1_context_set_illegal_callback(_cgo0, _cgo1, _cgo2); }()
	func() { _cgo0 := /*line :54:41*/context; var _cgo1 *[0]byte = _Ctype_callbackFunc /*line :54:64*/(_Cgo_ptr(_Cfpvar_fp_secp256k1GoPanicError /*line :54:88*/)); var _cgo2 _cgo_unsafe.Pointer = /*line :54:91*/nil; _cgoCheckPointer(_cgo0, nil); /*line :54:95*/_Cfunc_secp256k1_context_set_error_callback(_cgo0, _cgo1, _cgo2); }()
}

var (
	ErrInvalidMsgLen       = errors.New("invalid message length, need 32 bytes")
	ErrInvalidSignatureLen = errors.New("invalid signature length")
	ErrInvalidRecoveryID   = errors.New("invalid signature recovery id")
	ErrInvalidKey          = errors.New("invalid private key")
	ErrInvalidPubkey       = errors.New("invalid public key")
	ErrSignFailed          = errors.New("signing failed")
	ErrRecoverFailed       = errors.New("recovery failed")
)

// Sign creates a recoverable ECDSA signature.
// The produced signature is in the 65-byte [R || S || V] format where V is 0 or 1.
//
// The caller is responsible for ensuring that msg cannot be chosen
// directly by an attacker. It is usually preferable to use a cryptographic
// hash function on any input before handing it to this function.
func Sign(msg []byte, seckey []byte) ([]byte, error) {
	if len(msg) != 32 {
		return nil, ErrInvalidMsgLen
	}
	if len(seckey) != 32 {
		return nil, ErrInvalidKey
	}
	seckeydata := (* /*line :80:18*/_Ctype_uchar /*line :80:25*/)(unsafe.Pointer(&seckey[0]))
	if func() _Ctype_int{ _cgo0 := /*line :81:34*/context; var _cgo1 *_Ctype_uchar = /*line :81:43*/seckeydata; _cgoCheckPointer(_cgo0, nil); return /*line :81:54*/_Cfunc_secp256k1_ec_seckey_verify(_cgo0, _cgo1); }() != 1 {
		return nil, ErrInvalidKey
	}

	var (
		msgdata   = (* /*line :86:17*/_Ctype_uchar /*line :86:24*/)(unsafe.Pointer(&msg[0]))
		noncefunc = ( /*line :87:15*/*_Cvar_secp256k1_nonce_function_rfc6979 /*line :87:48*/)
		sigstruct  /*line :88:13*/_Ctype_secp256k1_ecdsa_recoverable_signature /*line :88:52*/
	)
	if func() _Ctype_int{ _cgo0 := /*line :90:40*/context; var _cgo1 *_Ctype_struct___8 = /*line :90:49*/&sigstruct; var _cgo2 *_Ctype_uchar = /*line :90:61*/msgdata; var _cgo3 *_Ctype_uchar = /*line :90:70*/seckeydata; var _cgo4 *[0]byte = /*line :90:82*/noncefunc; var _cgo5 _cgo_unsafe.Pointer = /*line :90:93*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :90:97*/_Cfunc_secp256k1_ecdsa_sign_recoverable(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() == 0 {
		return nil, ErrSignFailed
	}

	var (
		sig     = make([]byte, 65)
		sigdata = (* /*line :96:15*/_Ctype_uchar /*line :96:22*/)(unsafe.Pointer(&sig[0]))
		recid    /*line :97:11*/_Ctype_int /*line :97:16*/
	)
	func() _Ctype_int{ _cgo0 := /*line :99:60*/context; var _cgo1 *_Ctype_uchar = /*line :99:69*/sigdata; var _cgo2 *_Ctype_int = /*line :99:78*/&recid; var _cgo3 *_Ctype_struct___8 = /*line :99:86*/&sigstruct; _cgoCheckPointer(_cgo0, nil); return /*line :99:97*/_Cfunc_secp256k1_ecdsa_recoverable_signature_serialize_compact(_cgo0, _cgo1, _cgo2, _cgo3); }()
	sig[64] = byte(recid) // add back recid to get 65 bytes sig
	return sig, nil
}

// RecoverPubkey returns the public key of the signer.
// msg must be the 32-byte hash of the message to be signed.
// sig must be a 65-byte compact ECDSA signature containing the
// recovery id as the last element.
func RecoverPubkey(msg []byte, sig []byte) ([]byte, error) {
	if len(msg) != 32 {
		return nil, ErrInvalidMsgLen
	}
	if err := checkSignature(sig); err != nil {
		return nil, err
	}

	var (
		pubkey  = make([]byte, 65)
		sigdata = (* /*line :118:15*/_Ctype_uchar /*line :118:22*/)(unsafe.Pointer(&sig[0]))
		msgdata = (* /*line :119:15*/_Ctype_uchar /*line :119:22*/)(unsafe.Pointer(&msg[0]))
	)
	if func() _Ctype_int{ _cgo0 := /*line :121:35*/context; var _cgo1 *_Ctype_uchar = /*line :121:44*/(*_Ctype_uchar /*line :121:53*/)(unsafe.Pointer(&pubkey[0])); var _cgo2 *_Ctype_uchar = /*line :121:84*/sigdata; var _cgo3 *_Ctype_uchar = /*line :121:93*/msgdata; _cgoCheckPointer(_cgo0, nil); return /*line :121:101*/_Cfunc_secp256k1_ext_ecdsa_recover(_cgo0, _cgo1, _cgo2, _cgo3); }() == 0 {
		return nil, ErrRecoverFailed
	}
	return pubkey, nil
}

// VerifySignature checks that the given pubkey created signature over message.
// The signature should be in [R || S] format.
func VerifySignature(pubkey, msg, signature []byte) bool {
	if len(msg) != 32 || len(signature) != 64 || len(pubkey) == 0 {
		return false
	}
	sigdata := (* /*line :133:15*/_Ctype_uchar /*line :133:22*/)(unsafe.Pointer(&signature[0]))
	msgdata := (* /*line :134:15*/_Ctype_uchar /*line :134:22*/)(unsafe.Pointer(&msg[0]))
	keydata := (* /*line :135:15*/_Ctype_uchar /*line :135:22*/)(unsafe.Pointer(&pubkey[0]))
	return func() _Ctype_int{ _cgo0 := /*line :136:38*/context; var _cgo1 *_Ctype_uchar = /*line :136:47*/sigdata; var _cgo2 *_Ctype_uchar = /*line :136:56*/msgdata; var _cgo3 *_Ctype_uchar = /*line :136:65*/keydata; var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :136:82*/(len(pubkey)); _cgoCheckPointer(_cgo0, nil); return /*line :136:96*/_Cfunc_secp256k1_ext_ecdsa_verify(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() != 0
}

// DecompressPubkey parses a public key in the 33-byte compressed format.
// It returns non-nil coordinates if the public key is valid.
func DecompressPubkey(pubkey []byte) (x, y *big.Int) {
	if len(pubkey) != 33 {
		return nil, nil
	}
	var (
		pubkeydata = (* /*line :146:18*/_Ctype_uchar /*line :146:25*/)(unsafe.Pointer(&pubkey[0]))
		pubkeylen  =  /*line :147:16*/_Ctype_size_t /*line :147:24*/(len(pubkey))
		out        = make([]byte, 65)
		outdata    = (* /*line :149:18*/_Ctype_uchar /*line :149:25*/)(unsafe.Pointer(&out[0]))
		outlen     =  /*line :150:16*/_Ctype_size_t /*line :150:24*/(len(out))
	)
	if func() _Ctype_int{ _cgo0 := /*line :152:37*/context; var _cgo1 *_Ctype_uchar = /*line :152:46*/outdata; var _cgo2 _Ctype_size_t = /*line :152:55*/outlen; var _cgo3 *_Ctype_uchar = /*line :152:63*/pubkeydata; var _cgo4 _Ctype_size_t = /*line :152:75*/pubkeylen; _cgoCheckPointer(_cgo0, nil); return /*line :152:85*/_Cfunc_secp256k1_ext_reencode_pubkey(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == 0 {
		return nil, nil
	}
	return new(big.Int).SetBytes(out[1:33]), new(big.Int).SetBytes(out[33:])
}

// CompressPubkey encodes a public key to 33-byte compressed format.
func CompressPubkey(x, y *big.Int) []byte {
	var (
		pubkey     = S256().Marshal(x, y)
		pubkeydata = (* /*line :162:18*/_Ctype_uchar /*line :162:25*/)(unsafe.Pointer(&pubkey[0]))
		pubkeylen  =  /*line :163:16*/_Ctype_size_t /*line :163:24*/(len(pubkey))
		out        = make([]byte, 33)
		outdata    = (* /*line :165:18*/_Ctype_uchar /*line :165:25*/)(unsafe.Pointer(&out[0]))
		outlen     =  /*line :166:16*/_Ctype_size_t /*line :166:24*/(len(out))
	)
	if func() _Ctype_int{ _cgo0 := /*line :168:37*/context; var _cgo1 *_Ctype_uchar = /*line :168:46*/outdata; var _cgo2 _Ctype_size_t = /*line :168:55*/outlen; var _cgo3 *_Ctype_uchar = /*line :168:63*/pubkeydata; var _cgo4 _Ctype_size_t = /*line :168:75*/pubkeylen; _cgoCheckPointer(_cgo0, nil); return /*line :168:85*/_Cfunc_secp256k1_ext_reencode_pubkey(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == 0 {
		panic("libsecp256k1 error")
	}
	return out
}

func checkSignature(sig []byte) error {
	if len(sig) != 65 {
		return ErrInvalidSignatureLen
	}
	if sig[64] >= 4 {
		return ErrInvalidRecoveryID
	}
	return nil
}
